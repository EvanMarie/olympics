# -*- coding: utf-8 -*-
"""olympics_project_notebook.ipynb

Visit http://www.evanmarie.com/the-olympics-deep-data-analysis for the article and full explanation of this project.

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qskWzn9lZ0cKnaxQrEBLM8ES_icMlvn8
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install urllib
# !pip install yfinance
# from urllib.request import urlretrieve
# from zipfile import ZipFile
# url = 'https://mydatabucky.s3.amazonaws.com/olympics_helpers.py'
# urlretrieve(url, "olympics_helpers.py")
# url_02 = 'https://mydatabucky.s3.amazonaws.com/olympics_data.zip'
# urlretrieve(url_02, "olympics_data.zip")

"""<center> <font size = 6> ◅ Olympics: Deep Data Analysis ▻ <br></font>
<font size = 4><b>~ Evan Marie Carr (www.EvanMarie.com)</b></font></center>
<br>
<font size = 5> A comprehensive project on data import, cleaning, data merging, and statistics as well as advanced data visualization with Seaborn</font></div>
</center></font>
  
 <b>Section Links: </b></font><br>

<font size = 4>
 
1. [Datasets](#data)
2. [Merging and Organizing](#merging)
3. [Data Cleaning](#cleaning)
4. [Most Successful Countries](#most_successful)
5. [Top 50 Countries Aggregated](#top_50)
6. [Ranks Dataframe](#ranks)
7. [Statistics with the Ranks Dataframe](#statistics)
8. [Cross Tabulations and `top_50_ranking_countries`](#metal_ranks)
9. [Top Competing Countries in a Sport](#top_competing)
10. [Top Sports for a Country](#top_sports_by_country)
11. [Sports and Countries Ranks Dataframe](#sports_countries_ranks)
12. [Effects of Geographical Location](#geography)
13. [Effects of Culture](#culture)
14. [National and Traditional Sports](#ranks_sports)
</font>
</div>
    

<a id='data'></a>

<center>  <font size = 6> ◅ Datasets ▻ </font>

<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font></center>
<br>
<font size = 4>
        → <b>summer.csv</b> - all summer medals from 1896 to 2012 <br>
        → <b>winter.csv</b> - all winter medals from 1924 to 2014<br>
        → <b>dictionary.csv</b> - country info: country code, population, and GDP per capita
</div>

"""

import pandas as pd
import olympics_helpers as h
from IPython.core.display import HTML
pd.options.display.float_format = '{:,.0f}'.format
bgcolor ='#205373'; text_color = '#F2E6C2'
innerbackcolor = "#C4E1F2"; outerbackcolor = "#205373"; fontcolor = "#F2E6C2"

"""<div class="comment"><font size = 4><b> ➣ Importing CSV files </b></font></div>"""

with ZipFile("olympics_data.zip") as data:
	data.extractall()
	
summer = pd.read_csv("Project_12_Materials/summer.csv")
winter = pd.read_csv("Project_12_Materials/winter.csv")
dictionary = pd.read_csv("Project_12_Materials/dictionary.csv")

"""<center><font size = 5> ◅ Summer Dataframe ▻"""

h.overview(summer, title = 'summer')

"""<div class = "comment"><font size = 4><b> ➣ Changing summer dataframe column names to lower case</font></b></div>"""

summer.columns = [x.lower().strip() for x in list(summer.columns)]

h.display_me(summer, 5, "summer games")

"""<center><font size = 5> ◅ Winter Dataframe ▻"""

h.overview(winter, title="winter")

"""<div class = "comment"><font size = 4><b> ➣ Changing winter dataframe column names to lower case </font></b></div>"""

winter.columns = [x.lower().strip() for x in list(winter.columns)]

h.display_me(winter, 5, "winter games")

"""<center><font size = 5> ◅ Countries Dictionary ▻"""

h.overview(dictionary, title="dictionary")

"""<div class = "comment"><font size=4> ➣ Changing dictionary dataframe column names to lower case and removing white spaces, replacing them with underscores for easier use with code.</div></font>"""

dictionary.columns = [x.lower().replace(" ", "_") for x in list(dictionary.columns)]

h.fancy_plot(dictionary.describe(), kind = "bar", 
			 title = "Population vs. GDP Per Capita", legend_loc = 'upper left', 
			 xlabel="Statistical Metrics", ylabel="log(values)", logy=True, 
			 cmap = 'tab20b', label_rot = None)

h.display_me(dictionary, 5, title="dictionary")

# country = input("Look up a country: ")
# display(dictionary.loc[dictionary['country'] == country.capitalize()])

"""<a id="merging"></a>

<center><font size = 6>  1. Merging & Organizing
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>
	
<div class="mkdn_div">
    
→ Merging `summer` and `winter` (one row for each Medal awarded in any Olympic Games)<br>
→ Saving the merged DataFrame in as `olympics.csv`</b>. <br>
→ Adding the column `season` to indicate `summer` or `winter`<br>
→ Adding the complete country name to each row<br>
</div>

<div class = "comment">

<font size = 5> `pd.concat()`[[docs]](https://pandas.pydata.org/docs/reference/api/pandas.concat.html)</font><br>
    
> - since both dataframes have the same column names, they can be vertically concatenated this way<br>
> - pass the two dataframes to be concatenated as a list<br>
> - pass `axis = 0` to vertically concatenate<br>
> - `keys = ['summer', 'winter']` - the categorical terms corresponding to each respective dataframe that will be in the column created, season`<br>
> - ``reset_index()`` - without this, we would have a two-level index, but this way we get a range index<br>
> - `drop(columns = "level_1")` - without this, we have both the previous df indices as well as the new range index created with `reset_index()`. So we drop the old index here.<br>
  
<div>
"""

olympics = pd.concat([summer, winter], axis = 0, keys = ["summer", "winter"],
          names = ["season"]).reset_index().drop(columns = "level_1")

"""<div class = "comment">

    
<font size = 5> `df.merge()` [[docs]](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html)</font> <br>
> * Adding the country names from the countries dictionary to the concatenated Olympics dataframe <br>
> *  `olympics` is on left, and `dictionary.iloc[:,:2]` (the first two columns, country name and code) are on right
> * `how = "left"` because `olympics`, the df doing the merging, is on the left
> * `left_on = 'country'` the country code is the column labeled `country` in the left dataframe, which is `olympics`
> * `right_on = 'code'` the country code in the right dataframe, `dictionary`, is the column labeled `code`. This is like `JOIN ON` in `SQL` These two columns are where the two dataframes match
> * `drop(columns=["code"])` - This becomes a duplicate, since one of the joining columns also contains the country codes for all rows

<br>

→ renaming the columns affected by the merge, `country_x` and `country_y` to `country_code` and `country`


</div>
"""

olympics = olympics.merge(dictionary.iloc[:,:2], how = "left",
              left_on = 'country', right_on = 'code').drop(columns=["code"])

olympics.rename(columns = {"country_x": "country_code", "country_y": "country"}, inplace = True)

h.display_me(olympics, 3, "Concatenated Dataframe - Olympics", )

"""<a id="cleaning"></a>

<center><font size = 6> 2. Data Cleaning
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>
	
<div class="mkdn_div">
    
→ Add appropriate column headers to country codes and country names<br>
→ Remove spaces from column headers in dataframes<br>
→ Identify country names for codes that do not have a name to go with them<br>
→ Use the found country names to fill in the missing values<br>
→ Remove rows with unknown country code<br>
→ Reset index to <b>RangeIndex</b><br>
→ Convert `medal` to an ordered categorical column (`bronze` < `silver` < `gold`)<br>
</div>
"""

h.overview(olympics, 'olympics')

"""<div class = "comment"><font size=4>

➣ Investigating the 6,371 missing values described in the overview summary of our `olympics` dataframe above. </div></font>
"""

h.missing_values(olympics)

"""<div class = "comment"> <font size = 4> 
➣ Investigating the records with missing values in the country name column. </font></div>

"""

missing_country = olympics.loc[olympics.country.isnull()]
missing_country_indices = olympics.loc[olympics.country.isnull()].index
h.sample_df(missing_country, 8, title="Records Missing Country Name", width="60%")

h.fancy_plot(missing_country.country_code.value_counts().to_frame(), 
             kind = "bar", logy=True, title="Records Missing Country Names", 
             cmap = 'rainbow', legend_loc=None)

"""<div class = "comment"> <font size = 4> 
➣ The following code creates a list of the country codes for the countries that no longer exist and therefore do not have country names listed in the records for athletes from those countries. These records will have the old country names inserted below. </font></div>

"""

not_countries = list(olympics.loc[olympics.country.isnull()].\
                             country_code.value_counts().index)
h.list_to_table(not_countries, 4, 
                title = "Country Codes Missing Country Names", 
                width="50%")

old_countries = ['Soviet Union', 'East Germany', 'Romania', 'West Germany', 'Czechoslovakia', 'Yugoslavia', 'Unified Team', 'Unified Team of Germany', 'Mixed teams', 'Serbia', 'Australasia', 'Russian Empire', 'Montenegro', 'Trinidad and Tobago', 'Bohemia', 'West Indies Federation', 'Singapore', 'Independent Olympic Participants']

h.list_to_table(old_countries, 4, 
                title="Outdated Country Names to Be Inserted", width="50%")

country_mapping = pd.Series(index = not_countries,
                          name = "country", data = old_countries)

h.div_print("Outdated Country Codes and Their Countries", fontsize = 4, width='60%')
h.center_series(country_mapping)

"""<div class = "comment"> <font size = 4> 
➣ The following code will map the correct country names to the country codes for records without countries. 
"""

olympics.country.fillna(olympics.country_code.map(country_mapping), inplace=True)
h.sample_df(olympics[['season', 'year', 'city', 'sport', 'country_code', 'country']].loc[missing_country_indices], 4, "Previously missing countries have been filled", width="75%")

"""<div class = "comment"> <font size = 4> 
➣ The records that are still missing country codes and / or countries will be dropped from the dataframe. They show "athlete pending" and were probably disqualified for one reason or another. No more missing values in the olympics dataframe! The following code will also reset the index so that there is a continuous range index.
"""

display(olympics[olympics.country_code.isna()])

olympics.dropna(subset = ['country_code'], inplace = True)
olympics.reset_index(drop=True, inplace = True)
h.missing_values(olympics)

"""<div class = "comment"> <font size = 4>
	
➣ The following code cells will convert the `medals` column to categorical, which will save on memory and will be useful in sorting the medals hierarchically. This will be an ordered categorical column, which can be ordered from high to low or low to high. Since there is an order to the medals, this will be useful. 
 
> <font size=5> `pd.series.cat.set_categories()`</font> [[docs]](https://pandas.pydata.org/docs/reference/api/pandas.Series.cat.set_categories.html)
> * `pd.series.cat()` is a method specific to categorical columns (series)
> * `cat.set_categories()` allows the user to set the ascending order of the categories
> * `ordered = True` indicates that this is, in fact, and ordered categorical column

"""

olympics.medal = olympics.medal.astype('category')
olympics.medal = olympics.medal.cat.set_categories(['Bronze', 'Silver', 'Gold'],
                                 ordered = True)

h.center_series(olympics.medal.value_counts(), "Counts for Medals Values",
			    width="30%")

"""<a id="most_successful"></a>

<center><font size = 6> 3. Most Successful Countries </font>
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>
	
<div class="mkdn_div">
→ What are the top 10 countries by medals?<br>
→ Split the top 10 countries into summer and winter<br>
→ Investigate top countries for each season<br>
→ Split the top 10 countries into medal categories<br>
</div>
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
import matplotlib as mpl
mpl.rcParams.update({'text.color' : fontcolor,
                     'axes.labelcolor' : fontcolor})

h.sample_df(olympics, 5, "Cleaned Olympics Data")

"""<center><font size = 5> Top Ten Countries by Medal Wins """

top_ten_countries = olympics.country.value_counts().head(10)
h.center_series(top_ten_countries, 
			   title="Top Ten Countries by Medal Wins",
			   width="45%")

h.fancy_plot(top_ten_countries.sort_values().to_frame(), kind = 'barh', 
			 title = "Top Ten Medal-Winning Countries", legend_loc=None,
			cmap = 'plasma', ylabel="Top Ten Countries", xlabel = "Medal Counts")

top_ten_countries_df = olympics[olympics.country.isin(top_ten_countries.index)]
h.sample_df(top_ten_countries_df, 8, title="Top Ten Medal Winning Countries Dataframe")

"""<center><font size = 5> Visualization with Seaborn</center>

<div class = "comment"> <font size = 4>
	
<font size=5>
<br>
	
`sns.countplot()` [[docs]](https://seaborn.pydata.org/generated/seaborn.countplot.html)
</font>
* `data` - the dataframe from which to gather the data
* `x` - the largest categorization along the x axis
* `order` - the order of main x values along the axis
* `hue` - the differentiation between multiple values subdivided along the x axis
* `hue_order` - the order of the subdivided values along the x axis
* `palette` - the cmap or color list to use to differentiate subdivided values
"""

plt.figure(figsize=(13,7), facecolor= innerbackcolor)
sns.set(font_scale = 1.3, palette = "viridis")
sns.countplot(data = top_ten_countries_df, x = 'country', hue='season', 
			  order = top_ten_countries.index, palette = ["deeppink", "cyan"],
			 edgecolor= "black")
plt.title("Top Ten Countries: Summer vs Winter", fontsize=24, pad=20)
plt.tick_params(rotation=40)

plt.figure(figsize=(13,7), facecolor= innerbackcolor)
sns.set(font_scale = 1.3)
sns.countplot(data = top_ten_countries_df, x = 'season', 
			  hue='country', hue_order = top_ten_countries.index,
			 edgecolor= "black", palette = "rainbow")
plt.title("Top Ten Countries: Summer vs Winter", fontsize=24, pad=20)
plt.tick_params(rotation=40)

plt.figure(figsize=(13,7), facecolor= innerbackcolor)
sns.set(font_scale = 1.3, palette = "viridis")
sns.countplot(data = top_ten_countries_df, x = 'country', hue='medal', 
			  order = top_ten_countries.index, 
			  hue_order = ["Gold", "Silver", "Bronze"], 
			  palette = ["yellow", "silver", "brown"],
			 edgecolor= "black")
plt.title("Top Ten Countries: Medals Won", fontsize=24, pad=20)
plt.tick_params(rotation=40)

plt.figure(figsize=(13,7), facecolor= innerbackcolor)
sns.set(font_scale = 1.3)
sns.countplot(data = top_ten_countries_df, x = 'medal', hue='country', 
			  order = ["Gold", "Silver", "Bronze"], 
			  hue_order = top_ten_countries.index,
			 edgecolor= "black", palette="plasma")
plt.title("Top Ten Countries: Medals Won", fontsize=24, pad=20)
plt.tick_params(rotation=40)

"""<a id="top_50"></a>

<center><font size = 6> 4. Top 50 Countries Aggregated
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>
	
<div class="mkdn_div">
    
→ Investigating GDP, population, and politics<br>
→ Create aggregated and merged dataframe with the **top 50 countries**<br>
    → Columns = `country` (index), `total`, `gold`, `silver`, `bronze`, `population`, `GDP`, `total_games`.<br>
→ `total_games` column should show the number of olympics the country has participated in<br>
→ Determine the number of seasons where the countries have won at least one medal<br>
    </div>
"""

h.sample_df(olympics, 5, "Original Olympics Dataframe")

"""<div class = "comment"> <font size = 4>
	
➣ The following are the steps to aggregate the dataframe and get the number of each kind of medal won as well as total medals won by each country. This could be done with `pd.grouby()`. However, here I am using `pd.crosstab()` for simplicity, which computes a simple cross tabulation with multiple factors. Here those will be the country and the medal.
	
<br>
	
<font size=5>`pd.crosstab()` [[docs]](https://pandas.pydata.org/docs/reference/api/pandas.crosstab.html) - by default computes a frequency table. Other aggregation functions are also available. It is a summing up of the values between the `index` and `columns` data given to it.
</font>
* `index` - this is the data that will be used to effectively create rows
* `columns` - the data to be spread across the columns
* `margins` - passing true results in a sum across all rows and columns
* `margins_name` - the total sum across each row / column
	
---

The following code creates the aggregated dataframe, drops the sum that totals all rows (i.e. the last row of the dataframe, which is not really useful), reorders the columns and sorts the values by the countries with the most medals overall, then by gold, silver, and bronze. 

"""

countries_medals_counts = pd.crosstab(index = olympics.country, 
						columns = olympics.medal,
						margins = True, margins_name="Sum")

countries_medals_counts.drop('Sum', axis = 0, inplace=True)

countries_medals_counts = countries_medals_counts[["Sum", "Gold", 
						  "Silver", "Bronze"]].sort_values(by=["Sum", "Gold", 
															   "Silver", "Bronze"], 
														   ascending = False)

h.div_print("Dataframes prior to merging:", fontsize=5)
h.sample_df(countries_medals_counts, 3, "countries_medals_counts", width="50%")
h.sample_df(dictionary, 3, "dictionary", width="50%")

"""<div class = "comment"> <font size = 4>

The following code now merges the aggregated dataframe with the country info dictionary, joining on the index of `countries_medals_counts` and the `country` column in `dictionary`. It then drops the redundant country code column and sets the index once again to `country`. This effectively adds the columns `population` and `gdp_per_capita` to the aggregated dataframe.</font>
"""

countries_medals_counts = countries_medals_counts.merge(dictionary, how = "left",
						  left_index = True, right_on = "country").drop(columns = ["code"]).set_index("country")

h.display_me(countries_medals_counts, 5, title="Merged the Aggregated and Country Info Dataframes")

h.center_series(olympics.nunique(), "Unique Values in the Aggregation", width="50%")

"""<div class = "comment"> <font size = 4>

➣ The following code adds a column for unique Olympic games, combining the year and the city.
"""

olympics["games"] = olympics.apply(lambda x: str(x.year) + " - " + x.city, axis = 1)
h.sample_df(olympics[['season', 'year', 'city', 'athlete',
       'country_code', 'games']], 5, "Individual Games Column Added")

h.div_print(f"There have been {olympics.games.nunique()} unique Olympic Games.", fontsize=4, width="80%")

"""<div class = "comment"> <font size = 4>

➣ The following code gets the total number of medals awarded at each unique Olympic Games.
"""

h.center_df(olympics.games.value_counts().to_frame().head(10), 
			title="Top 10 Games with Most Medals Awarded", width="50%")

"""<div class = "comment"> <font size = 4>

➣ The following code gets the total number of unique Olympic Games each country has competed in. It will then add this data as a column to the aggregated countries dataframe.
"""

h.center_df(olympics.groupby("country").apply(lambda x: x.games.nunique()).sort_values(ascending=False).to_frame().head(10), title="Top 10 Competing Countries", width="40%")

countries_medals_counts['total_games'] = olympics.groupby("country").apply(lambda x: x.games.nunique())

h.center_df(countries_medals_counts.sort_values('total_games', ascending=False).head(10), title="Aggregated Data: Top 10 Competing Countries")

"""<a id="ranks"></a>

<center><font size = 6> 5. Total Medals Ranks Dataframe
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>
	

<div class="mkdn_div">
    
→ Convert the absolute values from the top 50 countries dataframe to ranks<br>
    → Columns = `country` (index), `total`, `gold`, `silver`, `bronze`, `population`, `GDP`, `total_games`<br>
→ This dataframe will include these columns with rankings<br>
</div>

<div class = "comment"> <font size = 4>

➣ The following code will get the relative ranks for each column of aggregated data. The dataframe is ordered by highest number of medals won overall.
"""

h.center_df(countries_medals_counts.rank(ascending=False).head(10), title = "Country Rankings", width = "90%")

"""<a id="statistics"></a>

<center><font size = 6> 6. Statistics with the Ranks Dataframe
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>
	
<div class="mkdn_div">
	
- determine whether `GDP`, `total_games`, and `population` have an effect on `total_medals`<br>
- `GDP` indicates the standard of living in a country<br>
- `total_games` indicates the political stability of a country<br>
- `population` indicates the overall size of a country<br>
    - Work with the `spearman` correlation
- Calculating correlation coefficients
- Discerning whether the coefficients are significantly different from 0, which indicates no relationship
- `pearson` method assumes that feature / variables are normally distributed
- `spearman rank correlation coefficient` assesses monotonic relationships, linear or not, and is less restrictive. 
	- It analyzes the relationship between the relative rankings between two variables rather than absolute.
	- The `spearman` correlation between two variables is equivalent to the `pearson` correlation between the rankings of two variables

</div>
"""

countries_medals_counts.drop(columns = ['Gold', 'Silver', 'Bronze'], inplace = True)

h.correlation_heatmap(countries_medals_counts, figsize=(5,5),
					 cmap="plasma", title="Pearson Correlation (Abs)", 
					  label_rot=30, method = 'pearson')

h.correlation_heatmap(countries_medals_counts, figsize=(5,5),
					 cmap="plasma", title="Spearman Correlation (Rank)", 
					  label_rot=30, method="spearman")

h.correlation_heatmap(countries_medals_counts.rank(ascending=False), figsize=(5,5),
					 cmap="plasma", title="Pearson of Rank (same as Spearman)", 
					  label_rot=30, method="pearson")

"""<div class = "comment"> 
<br>
	
<font size=5>`scipy.stats.spearmanr()` [[docs]](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.spearmanr.html)</font>

<font size = 4>
	
- using `scipy.stats.spearmanr()`, we can get the correlation between any two variables
- `pvalue` - this indicates <i>"the probability of an uncorrelated system producing datasets that have a Spearman correlation at least as extreme as the one computed from these datasets."</i>
	- i.e. an extreme outcome, a high correlation (range -1, no correlation, to 1, complete correlation) is very unlikely to occur by chance.
	- the correlation below of `0.419`, for example, indicates a high correlation between the total number of medals won and the population of a country
	- likewise, the correlation score of `0.458` indicates a large correlation between the total number of medals won by a country and their GDP
	- there is an incredibly high correlation between total number of medals won by a country and the country's total times participating in the Olympics
- pass the two columns to be compared
- pass the method of dealing with `NaN` values
"""

import scipy.stats as stats
stats.spearmanr(countries_medals_counts.Sum, countries_medals_counts.population,
			   nan_policy="omit")

stats.spearmanr(countries_medals_counts.Sum, countries_medals_counts.gdp_per_capita,
			   nan_policy="omit")

stats.spearmanr(countries_medals_counts.Sum, countries_medals_counts.total_games,
			   nan_policy="omit")

"""<a id="metal_ranks"></a>

<center><font size = 6> 7. Crosstabs & `top_50_ranking_countries` 
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>
	
<div class = "mkdn_div">
	
- crosstabs for summer vs winter and men vs women
- functions for searching the dataframe based on cross tabulations
- ranks dataframe for the top 50 ranking countries
- heatmap of the ranks dataframe for the top 15 countries<br>
- for each country, ranks for `total`, `women`, `men`, `winter`, and `summer` are included
- investigation of the rankings according to the different factors
- investigation of geographical location, culture and religion and how they affect participation
</div>
"""

summer_vs_winter = pd.crosstab(olympics.country, olympics.season)
h.sample_df(summer_vs_winter, 5, title = "Summer Vs Winter", width="45%")

men_vs_women = pd.crosstab(olympics.country, olympics.gender)
h.sample_df(men_vs_women, 5, title = "Men Vs Women", width="45%")

"""<a id="top_competing"></a>

<center><font size = 5> Top Competing Countries in a Sport
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>

<div class = "comment"> 
	
Using `pd.crosstab()`, I have created two functions to query the `olympics` dataframe. One function allows a user to query a sport and get the specified number of top competing countries in that sport, `top_competitors()`. The second takes a country and number of results and returns the top number of sports passed competed in by the country passed, `top_sports_for_country()`.
	
<br>

<font size=5>
	
`top_competitors()` - Look up a sport and the number of top competing countries in that sport.<br>

The options are: </font>
Swimming |  Athletics |  Cycling Road |  Cycling Track |  Fencing |  Artistic G. |  Shooting |  Tennis |  Weightlifting |  Wrestling Gre-R |  Water polo |  Archery |  Basque Pelota |  Cricket |  Croquet |  Jumping |  Football |  Golf |  Polo |  Rowing |  Rugby |  Sailing |  Tug of War |  Diving |  Boxing |  Lacrosse |  Roque |  Wrestling Free. |  Hockey |  Jeu de Paume |  Rackets |  Figure skating |  Water Motorspor |  Dressage |  Eventing |  Modern Pentath. |  Vaulting |  Ice Hockey |  Basketball |  Canoe / Kayak F |  Handball |  Judo |  Volleyball |  Canoe / Kayak S |  Synchronized S. |  Rhythmic G. |  Table Tennis |  Badminton |  Baseball |  Mountain Bike |  Softball |  Beach volley. |  Trampoline |  Taekwondo |  Triathlon |  BMX |  Marathon swimming |  Synchronized Swimming |  Water Polo |  Canoe Slalom |  Canoe Sprint |  Cycling BMX |  Gymnastics Artistic |  Gymnastics Rhythmic |  Modern Pentathlon |  Beach Volleyball |  Wrestling Freestyle |  Biathlon |  Bobsleigh |  Curling |  Speed skating |  Cross Country Skiing |  Nordic Combined |  Ski Jumping |  Skeleton |  Alpine Skiing |  Luge |  Short Track Speed Skating |  Freestyle Skiing |  Snowboard | 
	
"""

h.top_competitors(df=olympics)

"""<a id="top_sports_by_country"></a>

<center><font size = 5> Top Sports for a Country
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>

<div class = "comment"> <font size=5>
<br>

`top_sports_for_country()` - Look up a the top sports for a country.<br>

The country options are: </font>
Hungary  |  Austria  |  Greece  |  United States  |  Germany  |  United Kingdom  |  France  |  Australia  |  Denmark  |  Switzerland  |  Mixed teams  |  Netherlands  |  Belgium  |  India  |  Canada  |  Bohemia  |  Sweden  |  Norway  |  Spain  |  Italy  |  Cuba  |  Australasia  |  South Africa  |  Finland  |  Russian Empire  |  Estonia  |  Czechoslovakia  |  New Zealand  |  Brazil  |  Japan  |  Luxembourg  |  Argentina  |  Poland  |  Portugal  |  Uruguay  |  Yugoslavia  |  Romania  |  Haiti  |  Egypt  |  Philippines  |  Ireland  |  Chile  |  Latvia  |  Mexico  |  Turkey  |  Panama  |  Jamaica  |  Sri Lanka  |  Korea, South  |  Puerto Rico*  |  Peru  |  Iran  |  Trinidad and Tobago  |  Soviet Union  |  Venezuela  |  Bulgaria  |  Lebanon  |  Unified Team of Germany  |  Iceland  |  Pakistan  |  Bahamas  |  West Indies Federation  |  Taiwan  |  Ethiopia  |  Morocco  |  Ghana  |  Iraq  |  Singapore  |  Tunisia  |  Kenya  |  Nigeria  |  East Germany  |  West Germany  |  Uganda  |  Cameroon  |  Mongolia  |  Korea, North  |  Colombia  |  Niger  |  Thailand  |  Bermuda*  |  Tanzania  |  Guyana  |  Zimbabwe  |  China  |  Cote d'Ivoire  |  Zambia  |  Dominican Republic  |  Algeria  |  Syria  |  Suriname  |  Costa Rica  |  Indonesia  |  Senegal  |  Djibouti  |  Netherlands Antilles*  |  Virgin Islands*  |  Unified Team  |  Namibia  |  Qatar  |  Lithuania  |  Malaysia  |  Croatia  |  Israel  |  Slovenia  |  Independent Olympic Participants  |  Russia  |  Ukraine  |  Ecuador  |  Burundi  |  Mozambique  |  Czech Republic  |  Belarus  |  Tonga  |  Kazakhstan  |  Uzbekistan  |  Slovakia  |  Moldova  |  Georgia  |  Hong Kong*  |  Armenia  |  Azerbaijan  |  Barbados  |  Saudi Arabia  |  Kyrgyzstan  |  Kuwait  |  Vietnam  |  Macedonia  |  Serbia  |  Eritrea  |  Paraguay  |  United Arab Emirates  |  Sudan  |  Mauritius  |  Togo  |  Tajikistan  |  Afghanistan  |  Bahrain  |  Guatemala  |  Grenada  |  Botswana  |  Montenegro  |  Cyprus  |  Gabon  |  Liechtenstein   

"""

h.top_sports_for_country(df=olympics)

"""<div class = comment><font size=5>
	
Concatenated crosstabs for summer vs winter and for men vs. women.
"""

medals_categories = pd.concat([summer_vs_winter, men_vs_women], axis = 1)
medals_categories['total_medals'] = medals_categories.summer + medals_categories.winter
medals_categories.sort_values("total_medals", ascending=False, inplace=True)
h.sample_df(medals_categories, 8, title='Metals by Categories', width="50%")

h.center_df(medals_categories.head(5), title='Absolute Values for Top 5 Medal Winners', width="60%")

"""<a id="sports_countries_ranks"></a>

<center><font size = 5> Sport and Country Ranks Dataframe
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>

<div class = "comment"><font size = 4>
<br>
	
`pd.rank()` & `method = "average"` - if two countries share the same rank, they receive the average of that rank and the next
"""

metals_categories_ranks = medals_categories.rank(ascending = False, method = "average")
h.center_df(metals_categories_ranks.head(5), title = "Ranking Values for Top Five Medal Winners", width = "60%")

top_50_ranking_countries = metals_categories_ranks.head(50)

plt.figure(figsize = (10,5), facecolor = innerbackcolor)
sns.heatmap(top_50_ranking_countries.head(15).T, cmap = "plasma", annot=True,
		   fmt = "2.0f");
plt.title("Top 15 Medal Winners Heatmap", pad=20, size=20);

"""<a id="geography"></a>

<center><font size = 5> The Impact of Geographical Location</font>
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>

<div class = "mkdn_div">
- identify countries equally successful in summer and winter games<br>
- identify those most successful in summer<br>
- identify those most successful in winter<br>
</div>
"""

h.center_df(top_50_ranking_countries.sort_values("summer").head(5), title="Top 5 Ranking Countries for Summer Olympic Sports", width="70%")

h.center_df(top_50_ranking_countries.sort_values("winter").head(5), title="Top 5 Ranking Countries for Winter Olympic Sports", width="70%")

"""<div class = comment><font size = 5>
	
Investigating geographical location and success in summer games by way of a heatmap of the top 15 contenders in the summer Olympic Games. 
"""

plt.figure(figsize = (10,5), facecolor = innerbackcolor)
sns.heatmap(top_50_ranking_countries.sort_values(by="summer").head(15).T, cmap = "plasma", annot=True,
		   fmt = "2.0f");
plt.title("Top 15 Medal Winners for Summer Heatmap", pad=20, size=20);

"""<div class = comment><font size = 5>
	
Investigating geographical location and success in winter games by way of a heatmap of the top 15 contenders in the winter Olympic Games.
"""

plt.figure(figsize = (10,5), facecolor = innerbackcolor)
sns.heatmap(top_50_ranking_countries.sort_values(by="winter").head(15).T, cmap = "plasma", annot=True,
		   fmt = "2.0f");
plt.title("Top 15 Medal Winners for Winter Heatmap", pad=20, size=20);

"""<div class = comment><font size = 4>
	
The following is a heatmap of the differences in ranking between summer and winter. Countries in purple are primarily summer sport countries and in yellow are primarily winter sport countries. In the middle are the countries that are more evenly successful at both seasons.

"""

season_ranking_differences = top_50_ranking_countries.summer.\
						sub(top_50_ranking_countries.winter).sort_values().to_frame()

plt.figure(figsize = (20,5), facecolor = innerbackcolor)
sns.heatmap(season_ranking_differences.T, cmap = "plasma",
		   fmt = "2.0f");
plt.title("Top 50 Ranking: Summer vs Winter Distribution", pad=28, size=30);

"""<a id="culture"></a>

<center><font size = 5> The Impact of Culture and Religion</font>
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>

<div class = 'mkdn_div'>
- countries where men and women are equally successful<br>
- those where men are more successful<br>
- those where women are more successful<br>
</div>
"""

gender_ranking_differences = top_50_ranking_countries.Men.sub(top_50_ranking_countries.Women).sort_values().to_frame()

"""<div class = comment><font size = 5>
	
Investigating gender balance and participation in the Olympic Games by way of a heatmap of the top 15 contenders, organized by rankings of male athletes. 
"""

plt.figure(figsize = (10,5), facecolor = innerbackcolor)
sns.heatmap(top_50_ranking_countries.sort_values(by="Men").head(15).T, cmap = "cool", annot=True,
		   fmt = "2.0f");
plt.title("Top 15 Medal Winners for Men Heatmap", pad=20, size=20);

"""<div class = comment><font size = 5>
	
Investigating gender balance and participation in the Olympic Games by way of a heatmap of the top 15 contenders, organized by rankings of female athletes. 
"""

plt.figure(figsize = (10,5), facecolor = innerbackcolor)
sns.heatmap(top_50_ranking_countries.sort_values(by="Women").head(15).T, cmap = "cool", annot=True,
		   fmt = "2.0f");
plt.title("Top 15 Medal Winners for Women Heatmap", pad=20, size=20);

"""<div class = comment><font size = 4>
	
The following is a heatmap of the differences the balance of countries with male and female athletes. Countries in cyan have far more male athletes competing and in bright pink have far more female athletes competing. In the middle are the countries that are more evenly distributed among both genders.
"""

plt.figure(figsize = (20,5), facecolor = innerbackcolor)
sns.heatmap(gender_ranking_differences.T, cmap = "cool",
		   fmt = "2.0f");
plt.title("Top 50 Ranking: Men vs Women Distribution", pad=28, size=30);

"""<a id="ranks_sports"></a>

<center><font size = 6> 8. National Traditions and Sports
<font size = 3> 
	
JUMP TO: [Datasets](#data) | [Merging](#merging) | [Cleaning](#cleaning) | [Success](#most_successful) | [Top 50](#top_50) | [Ranks](#ranks) | [Statistics](#statistics) | [Cross-tabulations](#metal_ranks) |  [Top Competitors](#top_competing) |   [Top Sports](#top_sports_by_country) | [Sport & Country Ranks](#sports_countries_ranks) | [Geography](#geography) | [Culture](#culture)	| [National Traditions](#ranks_sports)</center> </font>
	
<div class = "mkdn_div">
	
- what sports are more popular in parituclar countries<br>
- how do national sports affect Olympic participation<br>
- how do core Olympic sports compare to the more fringe counterparts<br>
- heatmap showing ranks of the top 50 countries by sports <br>
- `x = sport`, `y = country` <br>
</div>
"""

sports_list = olympics.sport.value_counts().index # List of all sports in the data
top_25_sports = olympics.sport.value_counts().head(25) # Top 25 most popular sports
top_20_countries = olympics.country.value_counts().head(20).index # Top 20 winning countries

h.fancy_plot(top_25_sports.to_frame(), kind="bar", label_rot=90,
			legend_loc = None, title = "Top 25 Olympic Sports (Teams Included)",
			xlabel = "Sports", ylabel = "Medal Counts")

ranking_country_by_sport = pd.crosstab(olympics.country,
									   olympics.sport).rank(ascending=False,
															method='average')

h.sample_df(ranking_country_by_sport, 5, "Country Rankings (out of 145) by Sports")

top_20_sport_rankings = ranking_country_by_sport.loc[top_20_countries, sports_list].copy()
h.sample_df(top_20_sport_rankings, 5, "Top 20 Countries' Sports Rankings")

"""<div class = comment><font size = 4>
	
The following is a heatmap of the overall top 20 medal-winning countries and their rankings for each sporting event. Pink indicates high ranking in the sport.
"""

plt.figure(figsize = (20,10), facecolor = innerbackcolor)
sns.heatmap(top_20_sport_rankings, cmap = "spring",
		   vmin=1, vmax=6, linewidth=1);
plt.title("Top 20 Countries Sport Rankings", pad=20, size=30);
